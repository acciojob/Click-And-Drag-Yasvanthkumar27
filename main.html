<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Click and Drag</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="items">
    <div class="item item1">01</div>
    <div class="item item2">02</div>
    <div class="item item3">03</div>
    <div class="item item4">04</div>
    <div class="item item5">05</div>
    <div class="item item6">06</div>
    <div class="item item7">07</div>
    <div class="item item8">08</div>
    <div class="item item9">09</div>
    <div class="item item10">10</div>
    <div class="item item11">11</div>
    <div class="item item12">12</div>
    <div class="item item13">13</div>
    <div class="item item14">14</div>
    <div class="item item15">15</div>
    <div class="item item16">16</div>
    <div class="item item17">17</div>
    <div class="item item18">18</div>
    <div class="item item19">19</div>
    <div class="item item20">20</div>
    <div class="item item21">21</div>
    <div class="item item22">22</div>
    <div class="item item23">23</div>
    <div class="item item24">24</div>
    <div class="item item25">25</div>
  </div>

<script>
//Your code goes here 
	// Draggable items using pointer events
// Make .items visible and add container drag-to-scroll + item dragging
(() => {
  const container = document.querySelector('.items');
  if (!container) return;

  // --- 1) Ensure visibility for Cypress (in case prefill left it collapsed) ---
  // If the element has zero height, give it a reasonable minHeight so tests can interact.
  const rect = container.getBoundingClientRect();
  if (rect.height === 0) {
    container.style.minHeight = '240px';
    container.style.height = container.style.height || 'auto';
  }
  // ensure overflow settings expected by tests
  container.style.overflowX = 'auto';
  container.style.overflowY = 'hidden';
  container.style.position = container.style.position || 'relative';
  container.style.touchAction = 'none';

  // --- 2) Container drag-to-scroll (when dragging background / not on an .item) ---
  let isContainerDragging = false;
  let cStartX = 0;
  let cStartScroll = 0;

  container.addEventListener('pointerdown', (ev) => {
    // If user clicked on an item, do not start container scroll drag here.
    // The item drag logic (below) will handle item pointerdown.
    if (ev.target.closest('.item')) return;

    isContainerDragging = true;
    cStartX = ev.clientX;
    cStartScroll = container.scrollLeft;

    // style to indicate grabbing
    container.style.cursor = 'grabbing';
    // capture pointer so pointerup works even if pointer leaves viewport
    try { container.setPointerCapture(ev.pointerId); } catch(e) {}
    ev.preventDefault();
  }, { passive: false });

  document.addEventListener('pointermove', (ev) => {
    if (!isContainerDragging) return;
    ev.preventDefault();
    const dx = ev.clientX - cStartX;
    // invert movement to match typical drag-to-scroll UX
    container.scrollLeft = Math.round(cStartScroll - dx);
  }, { passive: false });

  document.addEventListener('pointerup', (ev) => {
    if (!isContainerDragging) return;
    isContainerDragging = false;
    container.style.cursor = 'pointer';
    try { container.releasePointerCapture(ev.pointerId); } catch(e) {}
  }, { passive: false });

  document.addEventListener('pointercancel', () => {
    if (!isContainerDragging) return;
    isContainerDragging = false;
    container.style.cursor = 'pointer';
  });

  // --- 3) Optional: Keep per-item dragging (so items can still be moved individually) ---
  // This code converts .item positions to absolute and allows dragging them inside container.
  // If you only want the container scroll behavior, you can remove this block.
  const items = Array.from(container.querySelectorAll('.item'));
  if (items.length === 0) return; // nothing further to do

  // Snapshot container rect and place items absolutely at their current visual positions
  const containerRect = container.getBoundingClientRect();
  items.forEach(it => {
    const r = it.getBoundingClientRect();
    const left = r.left - containerRect.left + container.scrollLeft;
    const top  = r.top  - containerRect.top  + container.scrollTop;

    it.style.position = 'absolute';
    it.style.left = Math.round(left) + 'px';
    it.style.top  = Math.round(top) + 'px';
    it.style.zIndex = 1;
    it.style.transition = 'left 0.06s linear, top 0.06s linear';
    it.style.userSelect = 'none';
    it.style.touchAction = 'none';
  });

  // Drag logic for items using pointer events
  let dragged = null;
  let pointerStart = {x:0, y:0};
  let elemStart = {left:0, top:0};
  const dragThreshold = 3;

  function itemPointerDown(e) {
    const target = e.target.closest('.item');
    if (!target) return;

    // If container is currently dragging, ignore item drag (avoid conflict)
    if (isContainerDragging) return;

    // capture pointer
    target.setPointerCapture(e.pointerId);
    dragged = { el: target, id: e.pointerId, moved: false };

    pointerStart.x = e.clientX;
    pointerStart.y = e.clientY;
    elemStart.left = parseFloat(target.style.left) || 0;
    elemStart.top  = parseFloat(target.style.top) || 0;

    target.style.transition = 'none';
    target.style.zIndex = 1000;
    e.preventDefault();
  }

  function itemPointerMove(e) {
    if (!dragged || e.pointerId !== dragged.id) return;
    e.preventDefault();
    const dx = e.clientX - pointerStart.x;
    const dy = e.clientY - pointerStart.y;
    if (!dragged.moved && Math.hypot(dx, dy) > dragThreshold) dragged.moved = true;

    const el = dragged.el;
    const maxLeft = container.clientWidth - el.offsetWidth;
    const maxTop  = container.clientHeight - el.offsetHeight;

    let newLeft = elemStart.left + dx;
    let newTop  = elemStart.top  + dy;

    if (newLeft < 0) newLeft = 0;
    if (newTop < 0) newTop = 0;
    if (newLeft > maxLeft) newLeft = maxLeft;
    if (newTop > maxTop) newTop = maxTop;

    el.style.left = Math.round(newLeft) + 'px';
    el.style.top  = Math.round(newTop) + 'px';
  }

  function itemPointerUp(e) {
    if (!dragged || e.pointerId !== dragged.id) return;
    const el = dragged.el;
    try { el.releasePointerCapture(e.pointerId); } catch(_) {}
    el.style.transition = 'left 0.06s linear, top 0.06s linear';
    el.style.zIndex = 1;
    dragged = null;
  }

  // attach item listeners (on container to support dynamic items too)
  container.addEventListener('pointerdown', (e) => itemPointerDown(e), { passive: false });
  document.addEventListener('pointermove', (e) => itemPointerMove(e), { passive: false });
  document.addEventListener('pointerup', (e) => itemPointerUp(e), { passive: false });
  document.addEventListener('pointercancel', (e) => itemPointerUp(e), { passive: falseÂ });

})();

</script>

  </body>
</html>
